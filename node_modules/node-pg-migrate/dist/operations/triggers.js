'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.undoRename = exports.rename = exports.create = exports.drop = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash');

var _utils = require('../utils');

var _functions = require('./functions');

var drop = exports.drop = function drop(table_name, trigger_name) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      ifExists = _ref.ifExists,
      cascade = _ref.cascade;

  return _utils.template`DROP TRIGGER${ifExists ? ' IF EXISTS' : ''} "${trigger_name}" ON "${table_name}"${cascade ? ' CASCADE' : ''};`;
};

var create = exports.create = function create(type_shorthands) {
  var _create = function _create(table_name, trigger_name) {
    var trigger_options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var definition = arguments[3];
    var constraint = trigger_options.constraint,
        condition = trigger_options.condition,
        operation = trigger_options.operation,
        deferrable = trigger_options.deferrable,
        deferred = trigger_options.deferred;
    var when = trigger_options.when,
        _trigger_options$leve = trigger_options.level,
        level = _trigger_options$leve === undefined ? 'STATEMENT' : _trigger_options$leve,
        functionName = trigger_options.function;

    var operations = (0, _lodash.isArray)(operation) ? operation.join(' OR ') : operation;
    if (constraint) {
      when = 'AFTER';
    }
    var isInsteadOf = /instead\s+of/i.test(when);
    if (isInsteadOf) {
      level = 'ROW';
    }
    if (definition) {
      functionName = functionName || trigger_name;
    }

    if (!when) {
      throw new Error('"when" (BEFORE/AFTER/INSTEAD OF) have to be specified');
    } else if (isInsteadOf && condition) {
      throw new Error('INSTEAD OF trigger can\'t have condition specified');
    }
    if (!operations) {
      throw new Error('"operation" (INSERT/UPDATE[ OF ...]/DELETE/TRUNCATE) have to be specified');
    }

    var defferClause = constraint ? `${deferrable ? `DEFERRABLE INITIALLY ${deferred ? 'DEFERRED' : 'IMMEDIATE'}` : 'NOT DEFERRABLE'}\n  ` : '';
    var conditionClause = condition ? `WHEN (${condition})\n  ` : '';

    var triggerSQL = _utils.template`CREATE${constraint ? ' CONSTRAINT' : ''} TRIGGER "${trigger_name}"
  ${when} ${operations} ON "${table_name}"
  ${defferClause}FOR EACH ${level}
  ${conditionClause}EXECUTE PROCEDURE "${functionName}"();`;

    return `${definition ? `${(0, _functions.create)(type_shorthands)(functionName, [], _extends({}, trigger_options, { returns: 'trigger' }), definition)}\n` : ''}${triggerSQL}`;
  };

  _create.reverse = function (table_name, trigger_name) {
    var trigger_options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var definition = arguments[3];
    return `${drop(table_name, trigger_name, trigger_options)}${definition ? `\n${(0, _functions.drop)(type_shorthands)(trigger_options.function || trigger_name, [], trigger_options)}` : ''}`;
  };

  return _create;
};

var rename = exports.rename = function rename(table_name, old_trigger_name, new_trigger_name) {
  return _utils.template`ALTER TRIGGER "${old_trigger_name}" ON "${table_name}" RENAME TO "${new_trigger_name}";`;
};

var undoRename = exports.undoRename = function undoRename(table_name, old_trigger_name, new_trigger_name) {
  return rename(table_name, new_trigger_name, old_trigger_name);
};

rename.reverse = undoRename;