'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dropConstraint = exports.addConstraint = exports.undoRenameConstraint = exports.renameConstraint = exports.undoRenameColumn = exports.renameColumn = exports.undoRenameTable = exports.renameTable = exports.alterColumn = exports.addColumns = exports.dropColumns = exports.create = exports.drop = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var formatLines = function formatLines(lines, replace) {
  var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',\n';
  return lines.join(separator).replace(/^/gm, replace);
};

var parseReferences = function parseReferences(options) {
  var references = options.references,
      _options$match = options.match,
      match = _options$match === undefined ? 'SIMPLE' : _options$match,
      onDelete = options.onDelete,
      onUpdate = options.onUpdate;

  var clauses = [typeof references === 'string' ? `REFERENCES ${references}` : _utils.template`REFERENCES "${references}"`];
  if (match) {
    clauses.push(`MATCH ${match}`);
  }
  if (onDelete) {
    clauses.push(`ON DELETE ${onDelete}`);
  }
  if (onUpdate) {
    clauses.push(`ON UPDATE ${onUpdate}`);
  }
  return clauses.join(' ');
};

var parseColumns = function parseColumns(columns) {
  var extending_type_shorthands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var columnsWithOptions = _lodash2.default.mapValues(columns, function (column) {
    return (0, _utils.applyType)(column, extending_type_shorthands);
  });

  var primaryColumns = _lodash2.default.chain(columnsWithOptions).map(function (options, column_name) {
    return options.primaryKey ? column_name : null;
  }).filter().value();
  var multiplePrimaryColumns = primaryColumns.length > 1;

  if (multiplePrimaryColumns) {
    columnsWithOptions = _lodash2.default.mapValues(columnsWithOptions, function (options) {
      return _extends({}, options, { primaryKey: false });
    });
  }

  return {
    columns: _lodash2.default.map(columnsWithOptions, function (options, column_name) {
      var type = options.type,
          collation = options.collation,
          defaultValue = options.default,
          unique = options.unique,
          primaryKey = options.primaryKey,
          notNull = options.notNull,
          check = options.check,
          references = options.references;

      var constraints = [];
      if (collation) {
        constraints.push(`COLLATE ${collation}`);
      }
      if (defaultValue !== undefined) {
        constraints.push(`DEFAULT ${(0, _utils.escapeValue)(defaultValue)}`);
      }
      if (unique) {
        constraints.push('UNIQUE');
      }
      if (primaryKey) {
        constraints.push('PRIMARY KEY');
      }
      if (notNull) {
        constraints.push('NOT NULL');
      }
      if (check) {
        constraints.push(`CHECK (${check})`);
      }
      if (references) {
        constraints.push(parseReferences(options));
      }

      var constraintsString = constraints.length ? ` ${constraints.join(' ')}` : '';

      return _utils.template`"${column_name}" ${type}${constraintsString}`;
    }),
    constraints: _extends({}, multiplePrimaryColumns ? { primaryKey: primaryColumns } : {})
  };
};

var parseConstraints = function parseConstraints(table, options) {
  var check = options.check,
      unique = options.unique,
      primaryKey = options.primaryKey,
      foreignKeys = options.foreignKeys,
      exclude = options.exclude,
      deferrable = options.deferrable,
      deferred = options.deferred;

  var table_name = typeof table === 'object' ? table.name : table;
  var constraints = [];
  if (check) {
    constraints.push(`CONSTRAINT "${table_name}_chck" CHECK (${check})`);
  }
  if (unique) {
    constraints.push(`CONSTRAINT "${table_name}_uniq" UNIQUE (${(0, _utils.quote)(_lodash2.default.isArray(unique) ? unique : [unique]).join(', ')})`);
  }
  if (primaryKey) {
    constraints.push(`CONSTRAINT "${table_name}_pkey" PRIMARY KEY (${(0, _utils.quote)(_lodash2.default.isArray(primaryKey) ? primaryKey : [primaryKey]).join(', ')})`);
  }
  if (foreignKeys) {
    (_lodash2.default.isArray(foreignKeys) ? foreignKeys : [foreignKeys]).forEach(function (fk) {
      var columns = fk.columns;

      constraints.push(`FOREIGN KEY (${(0, _utils.quote)(_lodash2.default.isArray(columns) ? columns : [columns]).join(', ')}) ${parseReferences(fk)}`);
    });
  }
  if (exclude) {
    constraints.push(`CONSTRAINT "${table_name}_excl" EXCLUDE ${exclude}`);
  }
  if (deferrable) {
    constraints.push(`DEFERRABLE INITIALLY ${deferred ? 'DEFERRED' : 'IMMEDIATE'}`);
  }

  return constraints;
};

// TABLE
var drop = exports.drop = function drop(table_name) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      ifExists = _ref.ifExists,
      cascade = _ref.cascade;

  return _utils.template`DROP TABLE${ifExists ? ' IF EXISTS' : ''} "${table_name}"${cascade ? ' CASCADE' : ''};`;
};

var create = exports.create = function create(type_shorthands) {
  var _create = function _create(table_name, columns) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var temporary = options.temporary,
        ifNotExists = options.ifNotExists,
        inherits = options.inherits,
        like = options.like,
        _options$constraints = options.constraints,
        optionsConstraints = _options$constraints === undefined ? {} : _options$constraints;

    var _parseColumns = parseColumns(columns, type_shorthands),
        columnLines = _parseColumns.columns,
        columnsConstraints = _parseColumns.constraints;

    var dupes = _lodash2.default.intersection(Object.keys(optionsConstraints), Object.keys(columnsConstraints));
    if (dupes.length > 0) {
      throw new Error(`There is duplicate constraint definition in table and columns options: ${dupes.join(', ')}`);
    }

    var constraints = _extends({}, optionsConstraints, columnsConstraints);
    var constraintLines = parseConstraints(table_name, constraints);
    var tableDefinition = [].concat(_toConsumableArray(columnLines), _toConsumableArray(constraintLines)).concat(like ? [_utils.template`LIKE "${like}"`] : []);

    return _utils.template`CREATE TABLE${temporary ? ' TEMPORARY' : ''}${ifNotExists ? ' IF NOT EXISTS' : ''} "${table_name}" (
${formatLines(tableDefinition, '  ')}
)${inherits ? _utils.template` INHERITS "${inherits}"` : ''};`;
  };
  _create.reverse = drop;
  return _create;
};

// COLUMNS
var dropColumns = exports.dropColumns = function dropColumns(table_name, columns) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      ifExists = _ref2.ifExists,
      cascade = _ref2.cascade;

  if (typeof columns === 'string') {
    columns = [columns]; // eslint-disable-line no-param-reassign
  } else if (!_lodash2.default.isArray(columns) && typeof columns === 'object') {
    columns = _lodash2.default.keys(columns); // eslint-disable-line no-param-reassign
  }
  return _utils.template`ALTER TABLE "${table_name}"
${formatLines((0, _utils.quote)(columns), `  DROP ${ifExists ? ' IF EXISTS' : ''}`, `${cascade ? ' CASCADE' : ''},\n`)};`;
};

var addColumns = exports.addColumns = function addColumns(type_shorthands) {
  var _add = function _add(table_name, columns) {
    var _parseColumns2 = parseColumns(columns, type_shorthands),
        columnLines = _parseColumns2.columns;

    return _utils.template`ALTER TABLE "${table_name}"\n${formatLines(columnLines, '  ADD ')};`;
  };
  _add.reverse = dropColumns;
  return _add;
};

var alterColumn = exports.alterColumn = function alterColumn(table_name, column_name, options) {
  var defaultValue = options.default,
      type = options.type,
      collation = options.collation,
      using = options.using,
      notNull = options.notNull,
      allowNull = options.allowNull;

  var actions = [];
  if (defaultValue === null) {
    actions.push('DROP DEFAULT');
  } else if (defaultValue !== undefined) {
    actions.push(`SET DEFAULT ${(0, _utils.escapeValue)(defaultValue)}`);
  }
  if (type) {
    actions.push(`SET DATA TYPE ${(0, _utils.applyTypeAdapters)(type)}${collation ? `COLLATE ${collation}` : ''}${using ? `USING ${using}` : ''}`);
  }
  if (notNull) {
    actions.push('SET NOT NULL');
  } else if (notNull === false || allowNull) {
    actions.push('DROP NOT NULL');
  }

  return _utils.template`ALTER TABLE "${table_name}"\n${formatLines(actions, `  ALTER "${column_name}" `)};`;
};

// RENAME
var renameTable = exports.renameTable = function renameTable(table_name, new_name) {
  return _utils.template`ALTER TABLE "${table_name}" RENAME TO "${new_name}";`;
};

var undoRenameTable = exports.undoRenameTable = function undoRenameTable(table_name, new_name) {
  return renameTable(new_name, table_name);
};

var renameColumn = exports.renameColumn = function renameColumn(table_name, column_name, new_name) {
  return _utils.template`ALTER TABLE "${table_name}" RENAME "${column_name}" TO "${new_name}";`;
};

var undoRenameColumn = exports.undoRenameColumn = function undoRenameColumn(table_name, column_name, new_name) {
  return renameColumn(table_name, new_name, column_name);
};

var renameConstraint = exports.renameConstraint = function renameConstraint(table_name, constraint_name, new_name) {
  return _utils.template`ALTER TABLE "${table_name}" RENAME CONSTRAINT "${constraint_name}" TO "${new_name}";`;
};

var undoRenameConstraint = exports.undoRenameConstraint = function undoRenameConstraint(table_name, constraint_name, new_name) {
  return renameConstraint(table_name, new_name, constraint_name);
};

// CONSTRAINTS -- only supports named check constraints
var addConstraint = exports.addConstraint = function addConstraint(table_name, constraint_name, expression) {
  return _utils.template`ALTER TABLE "${table_name}" ADD${constraint_name ? ` CONSTRAINT "${constraint_name}"` : ''} ${typeof expression === 'string' ? expression : parseConstraints(table_name, expression)};`;
};

var dropConstraint = exports.dropConstraint = function dropConstraint(table_name, constraint_name) {
  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      ifExists = _ref3.ifExists,
      cascade = _ref3.cascade;

  return _utils.template`ALTER TABLE "${table_name}" DROP CONSTRAINT${ifExists ? ' IF EXISTS' : ''} "${constraint_name}"${cascade ? ' CASCADE' : ''};`;
};

addColumns.reverse = dropColumns;
addConstraint.reverse = dropConstraint;
renameColumn.reverse = undoRenameColumn;
renameConstraint.reverse = undoRenameConstraint;
renameTable.reverse = undoRenameTable;